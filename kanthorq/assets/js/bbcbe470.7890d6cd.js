"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8178],{5014:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>c,toc:()=>u});var a=n(4848),s=n(8453),r=n(1470),l=n(9365);const i={title:"Task",sidebar_label:"Task",sidebar_position:4},o=void 0,c={id:"concepts/task",title:"Task",description:"If Event is DTO of client and KanthorQ publisher, Task is DTO of KanthorQ subscriber and client handler.",source:"@site/docs/002-concepts/004-task.md",sourceDirName:"002-concepts",slug:"/concepts/task",permalink:"/kanthorq/docs/concepts/task",draft:!1,unlisted:!1,editUrl:"https://github.com/kanthorlabs/kanthorq/tree/main/packages/create-docusaurus/templates/shared/docs/002-concepts/004-task.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Task",sidebar_label:"Task",sidebar_position:4},sidebar:"default",previous:{title:"Stream",permalink:"/kanthorq/docs/concepts/stream"},next:{title:"Consumer",permalink:"/kanthorq/docs/concepts/consumer"}},d={},u=[{value:"Task State",id:"task-state",level:3},{value:"Completed Flow",id:"completed-flow",level:4},{value:"Cancelled Flow",id:"cancelled-flow",level:4},{value:"Retryable &amp; Discarded Flow",id:"retryable--discarded-flow",level:4},{value:"Stuck Flow",id:"stuck-flow",level:4}];function h(e){const t={admonition:"admonition",code:"code",em:"em",h3:"h3",h4:"h4",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["If ",(0,a.jsx)(t.code,{children:"Event"})," is DTO of client and KanthorQ publisher, ",(0,a.jsx)(t.code,{children:"Task"})," is DTO of KanthorQ subscriber and client handler."]}),"\n",(0,a.jsxs)(t.p,{children:["So what is relationship between ",(0,a.jsx)(t.code,{children:"Event"})," and ",(0,a.jsx)(t.code,{children:"Task"}),"? It's one to many relationship. One event can generate as many tasks as we want but one task can only be referenced to one event"]}),"\n",(0,a.jsx)(t.mermaid,{value:"---\ntitle: Event & Task RelationShip\n---\nerDiagram\n  Event ||--}| Task: generates"}),"\n",(0,a.jsxs)(t.p,{children:["There is the definition of the ",(0,a.jsx)(t.code,{children:"Task"})," in different places in KanthorQ"]}),"\n",(0,a.jsxs)(r.A,{children:[(0,a.jsx)(l.A,{value:"go",label:"Go",default:!0,children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-go",children:'type Task struct {\n  EventId      string `json:"event_id"`\n  Topic        string `json:"topic"`\n  State        int16  `json:"state"`\n  ScheduleAt   int64  `json:"schedule_at"`\n  FinalizedAt  int64  `json:"finalized_at"`\n  AttemptCount int16  `json:"attempt_count"`\n  AttemptedAt  int64  `json:"attempted_at"`\n  CreatedAt    int64  `json:"created_at"`\n  UpdatedAt    int64  `json:"updated_at"`\n}\n'})})}),(0,a.jsx)(l.A,{value:"postgresql",label:"PostgreSQL",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"TABLE kanthorq_consumer_send_confirmed_email (\n  event_id VARCHAR(64) NOT NULL,\n  topic VARCHAR(128) NOT NULL,\n  state SMALLINT NOT NULL DEFAULT 1,\n  schedule_at BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) * 1000,\n  finalized_at BIGINT NOT NULL DEFAULT 0,\n  attempt_count SMALLINT NOT NULL DEFAULT 0,\n  attempted_at BIGINT NOT NULL DEFAULT 0,\n  created_at BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) * 1000,\n  updated_at BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) * 1000,\n)\n"})})})]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"schedule_at"})," is the time that a task will not be processed before that time. That mean if you schedule a task at ",(0,a.jsx)(t.em,{children:"10:00AM"}),", that task can be processed at any time after ",(0,a.jsx)(t.em,{children:"10:00AM"}),": ",(0,a.jsx)(t.em,{children:"10:01AM"})," or ",(0,a.jsx)(t.em,{children:"11:15AM"})," or ",(0,a.jsx)(t.em,{children:"02:00PM"})," for example"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"finalized_at"})," is the KanthorQ finally done with that task. No more action will be performed on a task after that time. If you want to do something with a task after that time, retry ",(0,a.jsx)(t.code,{children:"Discarded"})," for example, you need to do it manually"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"attempt_count"})," is how many time we have retried a task."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"attempted_at"})," is the latest attempt we have made for a task"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"task-state",children:"Task State"}),"\n",(0,a.jsx)(t.p,{children:"There are 6 states a task can have:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"Available"}),": is the state for tasks that are immediately eligible to be worked."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"Discarded"}),": is the state for tasks that have errored enough times that they're no longer eligible to be retried. Manual user invention is required for them to be tried again."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"Cancelled"}),": is the state for tasks that have been manually cancelled by user request."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"Completed"})," is the state for tasks that have successfully run to completion."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"Running"}),": is the state for tasks that are actively running."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"Retryable"})," is the state for tasks that have errored, but will be retried."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"We can categorize them into three groups"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Initial States"}),": The beginning state of a task before picking up to process. Currently we only have one state for this group: ",(0,a.jsx)(t.code,{children:"Available"})]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Transitional States"}),": Tasks will stay at this state for awhile before to be transformed to another state (which maybe as same as the current state based on the business logic). We have ",(0,a.jsx)(t.code,{children:"Running"})," and ",(0,a.jsx)(t.code,{children:"Retryable"})," now."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Final States"}),": Once the task is moved into this state, it will stay at that state until user manually handle it. We have totally three state: ",(0,a.jsx)(t.code,{children:"Discarded"}),", ",(0,a.jsx)(t.code,{children:"Cancelled"})," and ",(0,a.jsx)(t.code,{children:"Completed"})]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.mermaid,{value:"---\ntitle: State Transition Flow\n---\nstateDiagram-v2\n    [*] --\x3e Available\n\n    Available --\x3e Running\n    Running --\x3e Completed\n\n    Running --\x3e Running\n\n    Running --\x3e Retryable\n    Retryable --\x3e Running\n    Retryable --\x3e Discarded\n\n    Available --\x3e Cancelled\n\n    Discarded --\x3e [*]\n    Cancelled --\x3e [*]\n    Completed --\x3e [*]"}),"\n",(0,a.jsx)(t.h4,{id:"completed-flow",children:"Completed Flow"}),"\n",(0,a.jsx)(t.p,{children:"This is the most expected flow we want to see in the system. Nothing to say about it, lets check the diagram to see the flow"}),"\n",(0,a.jsx)(t.mermaid,{value:"---\ntitle: Completed Flow\n---\nstateDiagram-v2\n    direction LR\n    [*] --\x3e Available\n    Available --\x3e Running\n    Running --\x3e Completed\n    Completed --\x3e [*]"}),"\n",(0,a.jsx)(t.h4,{id:"cancelled-flow",children:"Cancelled Flow"}),"\n",(0,a.jsxs)(t.p,{children:["There are two direction to drive an event to ",(0,a.jsx)(t.code,{children:"Cancelled"})," state."]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Event is cancelled by user directly using system API after the task is initialized."}),"\n",(0,a.jsx)(t.mermaid,{value:"---\ntitle: Cancelled by user\n---\nstateDiagram-v2\n    direction LR\n    [*] --\x3e Available\n    Available --\x3e Cancelled\n    Cancelled --\x3e [*]"}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Event is cancelled after running by a program/worker/handler and the program/worker/handler decides to tell KanthorQ system should cancel that task."}),"\n",(0,a.jsx)(t.mermaid,{value:"---\ntitle: Cancelled by user\n---\nstateDiagram-v2\n    direction LR\n    [*] --\x3e Available\n    Available --\x3e Running\n    Running --\x3e Cancelled\n    Cancelled --\x3e [*]"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h4,{id:"retryable--discarded-flow",children:"Retryable & Discarded Flow"}),"\n",(0,a.jsxs)(t.p,{children:["Once the program/worker/handler return an error after processing the event, we will put the state into a state name ",(0,a.jsx)(t.code,{children:"Retryable"}),". Another process need setting up to pick up those events to move them back to ",(0,a.jsx)(t.code,{children:"Running"})," state before processing it again"]}),"\n",(0,a.jsx)(t.mermaid,{value:"---\ntitle: Retryable Flow\n---\nstateDiagram-v2\n    direction LR\n    [*] --\x3e Available\n    Available --\x3e Running\n    Running --\x3e Retryable\n    Retryable --\x3e Running"}),"\n",(0,a.jsxs)(t.p,{children:["But if the event countinuely return an error after configurable times, we should put that event to the ",(0,a.jsx)(t.code,{children:"Discarded"})," state. Once event is in ",(0,a.jsx)(t.code,{children:"Discarded"})," state, user need to investigate on those events by themself to figure out what wrong was happen. They they can move it back to ",(0,a.jsx)(t.code,{children:"Available"})," so they can be processed again"]}),"\n",(0,a.jsx)(t.mermaid,{value:"---\ntitle: Retryable Flow\n---\nstateDiagram-v2\n    direction LR\n    [*] --\x3e Available\n    Available --\x3e Running\n\n    Running --\x3e Retryable: if attempt_count <= X\n    Running --\x3e Discarded: if attempt_count > X\n\n    Discarded--\x3e [*]"}),"\n",(0,a.jsx)(t.h4,{id:"stuck-flow",children:"Stuck Flow"}),"\n",(0,a.jsx)(t.p,{children:"Stuck Flow is designed to handle unexpected behavious when a program/worker/handler picks a task then does not report whether the event is processed successfully or not. It happens when the program/worker/handler is crashed because of various issues around the system."}),"\n",(0,a.jsx)(t.mermaid,{value:"---\ntitle: Stuck Flow\n---\nstateDiagram-v2\n    direction LR\n    [*] --\x3e Available\n    Available --\x3e Running\n    Running --\x3e Running"}),"\n",(0,a.jsx)(t.admonition,{type:"danger",children:(0,a.jsxs)(t.p,{children:["Currently a stuck task will be process forever until it is moved to ",(0,a.jsx)(t.code,{children:"Retryable"})," or ",(0,a.jsx)(t.code,{children:"Discarded"}),". That decision was made because we belived the crashed issue should not be happened persistently. After a fix, all stuck events should be processed normally and no action need taking."]})})]})}function m(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},9365:(e,t,n)=>{n.d(t,{A:()=>l});n(6540);var a=n(4164);const s={tabItem:"tabItem_Ymn6"};var r=n(4848);function l(e){let{children:t,hidden:n,className:l}=e;return(0,r.jsx)("div",{role:"tabpanel",className:(0,a.A)(s.tabItem,l),hidden:n,children:t})}},1470:(e,t,n)=>{n.d(t,{A:()=>w});var a=n(6540),s=n(4164),r=n(3104),l=n(6347),i=n(205),o=n(7485),c=n(1682),d=n(679);function u(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??function(e){return u(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:s}}=e;return{value:t,label:n,attributes:a,default:s}}))}(n);return function(e){const t=(0,c.X)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function p(e){let{queryString:t=!1,groupId:n}=e;const s=(0,l.W6)(),r=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,o.aZ)(r),(0,a.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(s.location.search);t.set(r,e),s.replace({...s.location,search:t.toString()})}),[r,s])]}function b(e){const{defaultValue:t,queryString:n=!1,groupId:s}=e,r=h(e),[l,o]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:r}))),[c,u]=p({queryString:n,groupId:s}),[b,x]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[s,r]=(0,d.Dv)(n);return[s,(0,a.useCallback)((e=>{n&&r.set(e)}),[n,r])]}({groupId:s}),f=(()=>{const e=c??b;return m({value:e,tabValues:r})?e:null})();(0,i.A)((()=>{f&&o(f)}),[f]);return{selectedValue:l,selectValue:(0,a.useCallback)((e=>{if(!m({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);o(e),u(e),x(e)}),[u,x,r]),tabValues:r}}var x=n(2303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=n(4848);function j(e){let{className:t,block:n,selectedValue:a,selectValue:l,tabValues:i}=e;const o=[],{blockElementScrollPositionUntilNextRender:c}=(0,r.a_)(),d=e=>{const t=e.currentTarget,n=o.indexOf(t),s=i[n].value;s!==a&&(c(t),l(s))},u=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=o.indexOf(e.currentTarget)+1;t=o[n]??o[0];break}case"ArrowLeft":{const n=o.indexOf(e.currentTarget)-1;t=o[n]??o[o.length-1];break}}t?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":n},t),children:i.map((e=>{let{value:t,label:n,attributes:r}=e;return(0,v.jsx)("li",{role:"tab",tabIndex:a===t?0:-1,"aria-selected":a===t,ref:e=>o.push(e),onKeyDown:u,onClick:d,...r,className:(0,s.A)("tabs__item",f.tabItem,r?.className,{"tabs__item--active":a===t}),children:n??t},t)}))})}function g(e){let{lazy:t,children:n,selectedValue:s}=e;const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=r.find((e=>e.props.value===s));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:r.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==s})))})}function k(e){const t=b(e);return(0,v.jsxs)("div",{className:(0,s.A)("tabs-container",f.tabList),children:[(0,v.jsx)(j,{...t,...e}),(0,v.jsx)(g,{...t,...e})]})}function w(e){const t=(0,x.A)();return(0,v.jsx)(k,{...e,children:u(e.children)},String(t))}},8453:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>i});var a=n(6540);const s={},r=a.createContext(s);function l(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);