"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[542],{1429:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var s=t(4848),r=t(8453);const i={title:"Insert events",sidebar_label:"Insert events",sidebar_position:1},o=void 0,a={id:"guides/insert-events",title:"Insert events",description:"The first step in working with KanthorQ is inserting events into the system, which will remain there for you to process later (until you delete them). To do this, you need to understand the event structure in KanthorQ. Once familiar with it, I'll show you how to insert events in a basic way, as well as how to do so transactionally.",source:"@site/docs/002-guides/001-insert-events.md",sourceDirName:"002-guides",slug:"/guides/insert-events",permalink:"/kanthorq/docs/guides/insert-events",draft:!1,unlisted:!1,editUrl:"https://github.com/kanthorlabs/kanthorq/tree/main/packages/create-docusaurus/templates/shared/docs/002-guides/001-insert-events.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Insert events",sidebar_label:"Insert events",sidebar_position:1},sidebar:"default",previous:{title:"Guides",permalink:"/kanthorq/docs/category/guides"},next:{title:"Process events and tasks",permalink:"/kanthorq/docs/guides/process-events-and-tasks"}},d={},l=[{value:"The event structure",id:"the-event-structure",level:2},{value:"The <code>Subject</code>",id:"the-subject",level:3},{value:"The <code>Body</code>",id:"the-body",level:3},{value:"Other properties",id:"other-properties",level:3},{value:"Inserting Events (Basic Way)",id:"inserting-events-basic-way",level:2},{value:"Inserting Events (Transactional Way)",id:"inserting-events-transactional-way",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"The first step in working with KanthorQ is inserting events into the system, which will remain there for you to process later (until you delete them). To do this, you need to understand the event structure in KanthorQ. Once familiar with it, I'll show you how to insert events in a basic way, as well as how to do so transactionally."}),"\n",(0,s.jsx)(n.h2,{id:"the-event-structure",children:"The event structure"}),"\n",(0,s.jsxs)(n.p,{children:["An event in the KanthorQ system has the following structure. The most important properties you'll work with often are ",(0,s.jsx)(n.code,{children:"Subject"})," and ",(0,s.jsx)(n.code,{children:"Body"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'type Event struct {\n  Id        string   `json:"id" validate:"required"`\n  Subject   string   `json:"subject" validate:"required,is_subject"`\n  Body      []byte   `json:"body" validate:"required"`\n  Metadata  Metadata `json:"metadata" validate:"required"`\n  CreatedAt int64    `json:"created_at"`\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"the-subject",children:["The ",(0,s.jsx)(n.code,{children:"Subject"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Subject"})," property allows you to organize your events in a hierarchical structure. This concept is inspired by ",(0,s.jsx)(n.a,{href:"https://docs.nats.io/nats-concepts/subjects",children:"NATS Subject-Based Messaging"}),". If you're familiar with RabbitMQ, it's similar to a ",(0,s.jsx)(n.a,{href:"https://www.rabbitmq.com/tutorials/tutorial-five-go#topic-exchange",children:"Routing Key"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, if you have an event for an order update, you might define the subject as ",(0,s.jsx)(n.code,{children:"order.updated"}),". You can then write logic to handle this event."]}),"\n",(0,s.jsx)(n.p,{children:"As your business evolves, you might need to handle different versions of this event. You could either modify the existing logic or write new logic for the updated version."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["To support both old and new logic, you can define a new subject like ",(0,s.jsx)(n.code,{children:"order.updated.v2"}),". You can filter all versions using the pattern ",(0,s.jsx)(n.code,{children:"order.updated.>"})," so that both old and new events will be matched."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Alternatively, to keep old and new versions separate, you could define a subject like ",(0,s.jsx)(n.code,{children:"v2.order.updated"}),". Then ",(0,s.jsx)(n.code,{children:"order.updated.>"})," will match the old version, and ",(0,s.jsx)(n.code,{children:"v2.order.updated.>"})," will match the new one."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["If your business expands to multiple regions, you could further specify subjects like ",(0,s.jsx)(n.code,{children:"ap-southeast-1.order.created"}),", ",(0,s.jsx)(n.code,{children:"ap-southeast-2.order.created"}),", and so on."]}),"\n",(0,s.jsxs)(n.h3,{id:"the-body",children:["The ",(0,s.jsx)(n.code,{children:"Body"})]}),"\n",(0,s.jsx)(n.p,{children:"The Body is an arbitrary byte array where you can store any kind of data. The most common use case is storing a JSON string, but you could also store binary data, such as images, or even encrypt the body before storing it."}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'// pseudo code for demonstration\n\nbody, err := encrypt(...)\nif err !=nil {\n  log.Fatal(err)\n}\nevents := []*entities.Event{\n  entities.NewEvent("system.say_goodbye", body)),\n}\npub.Send(ctx, events)\n\n// Decrypt when receiving the event\nsub.Receive(ctx, func(ctx context.Context, msg *entities.Message) error {\n  data, err := decrypt(msg.Event.Body)\n  if err !=nil {\n    log.Fatal(err)\n  }\n\n  // Work with the decrypted data\n})\n'})}),"\n",(0,s.jsx)(n.h3,{id:"other-properties",children:"Other properties"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Metadata"}),": An arbitrary map to store additional information about your event, like telemetry tracing."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Id"}),": A crucial property serving as the primary and partition key of the stream. It must be lexicographically sortable. Common options include ",(0,s.jsx)(n.a,{href:"https://github.com/ulid/spec",children:"ULID"})," and ",(0,s.jsx)(n.a,{href:"https://github.com/segmentio/ksuid",children:"KSUID"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["KanthorQ is using ",(0,s.jsx)(n.code,{children:"ULID"})," by default."]})}),"\n",(0,s.jsx)(n.h2,{id:"inserting-events-basic-way",children:"Inserting Events (Basic Way)"}),"\n",(0,s.jsx)(n.p,{children:"To simplify the process, KanthorQ provides helper methods for initializing both the publisher and the event."}),"\n",(0,s.jsx)(n.p,{children:"To initialize a publisher, you need to define two options:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Connection"}),": The connection string for the PostgreSQL database."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"StreamName"}),": The name of the stream where events will be stored. It serves same as ",(0,s.jsx)(n.a,{href:"https://docs.nats.io/nats-concepts/jetstream/streams",children:"NATS JetStream Streams"})," or ",(0,s.jsx)(n.a,{href:"https://www.rabbitmq.com/tutorials/tutorial-three-go#exchanges",children:"RabbitMQ Exchange"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'options := &publisher.Options{\n  Connection: "postgres://postgres:changemenow@localhost:5432/postgres?sslmode=disable",\n  // Using default stream for demo\n  StreamName: entities.DefaultStreamName,\n}\n// Initialize a publisher\npub, cleanup := kanthorq.Pub(ctx, options)\n// Clean up after done\ndefer cleanup()\n'})}),"\n",(0,s.jsxs)(n.p,{children:["To initialize an event, define the ",(0,s.jsx)(n.code,{children:"Subject"})," and ",(0,s.jsx)(n.code,{children:"Body"})," using the ",(0,s.jsx)(n.code,{children:"NewEvent"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'subject := "system.say_hello"\nbody := []byte("{\\"msg\\": \\"Hello World!\\"}")\nevent := entities.NewEvent(subject, body)\nevent.Metadata["version"] = "2"\nevent.Metadata["traceparent"] = "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"\n'})}),"\n",(0,s.jsx)(n.p,{children:"Bringing it all together:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'options := &publisher.Options{\n  Connection: "postgres://postgres:changemenow@localhost:5432/postgres?sslmode=disable",\n  // Using default stream for demo\n  StreamName: entities.DefaultStreamName,\n}\n// Initialize a publisher\npub, cleanup := kanthorq.Pub(ctx, options)\n// Clean up after done\ndefer cleanup()\n\nsubject := "system.say_hello"\nbody := []byte("{\\"msg\\": \\"Hello World!\\"}")\nevent := entities.NewEvent(subject, body)\nevent.Metadata["version"] = "2"\nevent.Metadata["traceparent"] = "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"\n\n// Publish events\nevents := []*entities.Event{event}\nif err:= pub.Send(ctx, events); err != nil {\n  // Handle error\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"inserting-events-transactional-way",children:"Inserting Events (Transactional Way)"}),"\n",(0,s.jsx)(n.p,{children:"One of the key features of KanthorQ is the ability to publish events transactionally, ensuring events are only published if the entire transaction is successful."}),"\n",(0,s.jsx)(n.p,{children:"For example, when updating an order as the example we mentioned at the beginning, you can ensure that both the update and the event publishing are either fully successful or both fail."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-go",children:'options := &publisher.Options{\n  Connection: "postgres://postgres:changemenow@localhost:5432/postgres?sslmode=disable",\n  StreamName: entities.DefaultStreamName,\n}\npub, cleanup := kanthorq.Pub(ctx, options)\ndefer cleanup()\n\nsubject := "order.updated"\nbody := []byte("{\\"txn_id\\": \\"afe86f5d-66a0-49ca-8c18-fbea71dc2a98\\"}")\nevent := entities.NewEvent(subject, body)\nevent.Metadata["traceparent"] = "00-80e1afed08e019fc1110464cfa66635c-7a085853722dc6d2-01"\n\nevents := []*entities.Event{event}\n\n// ------------ THE DIFFERENT IS HERE ---------\n// Start a new transaction\nconn, err := pgx.Connect(ctx, cm.uri)\nif err != nil {\n  return nil, err\n}\ntx, err := conn.BeginTx(ctx, pgx.TxOptions{})\nif err != nil {\n  return nil, err\n}\n\n// Publish events transactionally\nif err:= pub.SendTx(ctx, events, tx); err != nil {\n  // handle error\n}\n\n// do other stuff\n// call tx.Rollback(ctx) to abort the transaction\n\n// Commit the transaction\nif err := tx.Commit(ctx); err != nil {\n  // handle error\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["For a full example, see our documentation on ",(0,s.jsx)(n.a,{href:"https://github.com/kanthorlabs/kanthorq/blob/main/example/transactional-publisher/main.go",children:"Transactional Publisher"})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);