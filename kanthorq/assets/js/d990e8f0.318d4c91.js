"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4412],{5216:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var a=t(4848),s=t(8453);const o={title:"Task acknowledgement",sidebar_label:"Task acknowledgement",sidebar_position:3},c=void 0,r={id:"guides/task-acknowledgement",title:"Task acknowledgement",description:"Implicit acknowledgement",source:"@site/docs/002-guides/003-task-acknowledgement.md",sourceDirName:"002-guides",slug:"/guides/task-acknowledgement",permalink:"/kanthorq/docs/guides/task-acknowledgement",draft:!1,unlisted:!1,editUrl:"https://github.com/kanthorlabs/kanthorq/tree/main/packages/create-docusaurus/templates/shared/docs/002-guides/003-task-acknowledgement.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Task acknowledgement",sidebar_label:"Task acknowledgement",sidebar_position:3},sidebar:"default",previous:{title:"Process events and tasks",permalink:"/kanthorq/docs/guides/process-events-and-tasks"},next:{title:"Concepts",permalink:"/kanthorq/docs/category/concepts"}},i={},l=[{value:"Implicit acknowledgement",id:"implicit-acknowledgement",level:2},{value:"Explicit acknowledgement",id:"explicit-acknowledgement",level:2},{value:"Transactional acknowledgement",id:"transactional-acknowledgement",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"implicit-acknowledgement",children:"Implicit acknowledgement"}),"\n",(0,a.jsx)(n.p,{children:"By default, all subscribers will use implicit acknowledgement. That means KanthorQ system will automatically acknowledge tasks if there are no returng error in your handler. Otherwise, it will mark the task is not acknowledged and it should be retried."}),"\n",(0,a.jsx)(n.p,{children:"The handler interface is described like this"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:"type Handler func(ctx context.Context, msg *Message) error\n"})}),"\n",(0,a.jsxs)(n.p,{children:["And there is the ",(0,a.jsx)(n.code,{children:"Message"})," struct which contains the event and task information."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:"type Message struct {\n  // the event you push into a stream\n  Event *entities.Event\n  // the task that was generated from the event\n  // contains all necessary about your execution on the event\n  Task  *entities.Task\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"explicit-acknowledgement",children:"Explicit acknowledgement"}),"\n",(0,a.jsx)(n.p,{children:"Sometime, you want to acknowledge the task manually, commit the acknowledgement to the database along with your business logic. So either you do something successfully and commit it to be done or nothing will be commited at all."}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"Message"})," struct provide two methods ",(0,a.jsx)(n.code,{children:"Ack"})," and ",(0,a.jsx)(n.code,{children:"Nack"})," to acknowledge or no-acknowledge the message respectively. Both of them are safe to call multiple times and concurrently."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:"func (msg *Message) Ack(ctx context.Context) error\n// Nack requires one more parameter `reason`\n// so that we can know why the message is nacked and you can retrie it later\nfunc (msg *Message) Nack(ctx context.Context, reason error) error\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"danger",children:(0,a.jsxs)(n.p,{children:["So what happen if ",(0,a.jsx)(n.code,{children:"Ack"})," and ",(0,a.jsx)(n.code,{children:"Nack"})," are not successful? You need to retry it manually by yourself to guarantee consistency across your application."]})}),"\n",(0,a.jsxs)(n.p,{children:["And there is an demonstration of how to use ",(0,a.jsx)(n.code,{children:"Ack"})," and ",(0,a.jsx)(n.code,{children:"Nack"})," explicitly. See ",(0,a.jsx)(n.a,{href:"https://github.com/kanthorlabs/kanthorq/blob/main/example/acknowledgement/main.go",children:"Acknowledgement example"})," for complete code."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'func(ctx context.Context, msg *subscriber.Message) error {\n  // someone say hello, accept it\n  if msg.Event.Subject == "system.say_hello" {\n    return msg.Ack(ctx)\n  }\n  // I will miss you don\'t want to say goodbye, not acknowledge it\n  return msg.Nack(ctx, errors.New("not saying goodbye"))\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"transactional-acknowledgement",children:"Transactional acknowledgement"}),"\n",(0,a.jsxs)(n.p,{children:["KanthorQ takes advantages of PostgreSQL's ACID transactional model to provide many features that ensures data consistency across your application. Like previous article about ",(0,a.jsx)(n.a,{href:"/kanthorq/docs/guides/insert-events#insert-events-in-a-transactional-way",children:"Insert events in a transactional way"}),", you can also acknowledge task in a transactional way."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'// start the transcation\ntx, err := conn.Begin(ctx)\nif err != nil {\n  return err\n}\n// do some business logic with the transaction\n\nkanthorq.Sub(ctx, options,\tfunc(ctx context.Context, msg *subscriber.Message) error {\n  if msg.Event.Subject == "system.say_hello" {\n    // acknowledge it with the transaction\n    return msg.AckTx(ctx, tx)\n  }\n  // or nack it, also with the transaction\n  return msg.NackTx(ctx, errors.New("not saying goodbye"))\n})\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>r});var a=t(6540);const s={},o=a.createContext(s);function c(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),a.createElement(o.Provider,{value:n},e.children)}}}]);