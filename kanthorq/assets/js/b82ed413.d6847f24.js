"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[542],{1429:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var s=n(4848),i=n(8453);const r={title:"Insert events",sidebar_label:"Insert events",sidebar_position:1},a=void 0,o={id:"guides/insert-events",title:"Insert events",description:"The first step in working with the KanthorQ system is inserting events. Once an event is inserted, it will remain in the system indefinitely, ready to be processed at any time (unless you delete it). Before you can insert events, it\u2019s important to understand the structure of events in the KanthorQ system. This section will cover the structure of events, how to insert them in a basic manner, and how to do so transactionally, ensuring that events are only added if the associated transaction succeeds.",source:"@site/docs/002-guides/001-insert-events.md",sourceDirName:"002-guides",slug:"/guides/insert-events",permalink:"/kanthorq/docs/guides/insert-events",draft:!1,unlisted:!1,editUrl:"https://github.com/kanthorlabs/kanthorq/tree/main/packages/create-docusaurus/templates/shared/docs/002-guides/001-insert-events.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Insert events",sidebar_label:"Insert events",sidebar_position:1},sidebar:"default",previous:{title:"Guides",permalink:"/kanthorq/docs/category/guides"},next:{title:"Handle events and tasks",permalink:"/kanthorq/docs/guides/handle-events-and-tasks"}},d={},c=[{value:"The event structure",id:"the-event-structure",level:2},{value:"The <code>Subject</code>",id:"the-subject",level:3},{value:"The <code>Body</code>",id:"the-body",level:3},{value:"Other properties",id:"other-properties",level:3},{value:"Inserting Events (Basic Way)",id:"inserting-events-basic-way",level:2},{value:"Inserting Events (Transactional Way)",id:"inserting-events-transactional-way",level:2}];function l(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"The first step in working with the KanthorQ system is inserting events. Once an event is inserted, it will remain in the system indefinitely, ready to be processed at any time (unless you delete it). Before you can insert events, it\u2019s important to understand the structure of events in the KanthorQ system. This section will cover the structure of events, how to insert them in a basic manner, and how to do so transactionally, ensuring that events are only added if the associated transaction succeeds."}),"\n",(0,s.jsx)(t.h2,{id:"the-event-structure",children:"The event structure"}),"\n",(0,s.jsxs)(t.p,{children:["An event in the KanthorQ system follows a predefined structure, as shown below. The most frequently used properties in the event structure are ",(0,s.jsx)(t.code,{children:"Subject"})," and ",(0,s.jsx)(t.code,{children:"Body"}),", which you will interact with often."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'type Event struct {\n  Id        string   `json:"id" validate:"required"`\n  Subject   string   `json:"subject" validate:"required,is_subject"`\n  Body      []byte   `json:"body" validate:"required"`\n  Metadata  Metadata `json:"metadata" validate:"required"`\n  CreatedAt int64    `json:"created_at"`\n}\n'})}),"\n",(0,s.jsxs)(t.h3,{id:"the-subject",children:["The ",(0,s.jsx)(t.code,{children:"Subject"})]}),"\n",(0,s.jsxs)(t.p,{children:["The Subject field is a crucial part of an event's structure. It allows you to organize your events in a hierarchical manner, similar to the concept of ",(0,s.jsx)(t.a,{href:"https://docs.nats.io/nats-concepts/subjects",children:"NATS Subject-Based Messaging"}),". If you're familiar with RabbitMQ, you can think of it as being similar to a",(0,s.jsx)(t.a,{href:"https://www.rabbitmq.com/tutorials/tutorial-five-go#topic-exchange",children:"Routing Key"}),", which determines how messages (or in this case, events) are routed to different consumers."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, if you are working with events related to order updates, you can define a subject like ",(0,s.jsx)(t.code,{children:"order.updated"}),". This allows you to easily organize all events that deal with order updates under a single subject. You can also define more granular subjects depending on your needs."]}),"\n",(0,s.jsx)(t.p,{children:"As your system evolves, you may need to introduce new logic to handle the events, perhaps as a result of changing business requirements. In such cases, you will need to decide whether to update the existing logic or create a new version of the event processing logic."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["If you choose to support both the old and the new logic simultaneously, you can define a new subject like ",(0,s.jsx)(t.code,{children:"order.updated.v2"}),". This will allow you to filter both the old and new versions of the event using a single pattern, such as ",(0,s.jsx)(t.code,{children:"order.updated.>"}),", which would match all versions of the ",(0,s.jsx)(t.code,{children:"order.updated"})," subject."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:["On the other hand, if you choose to keep the new logic separate from the old, you can define a subject like ",(0,s.jsx)(t.code,{children:"v2.order.updated"}),". In this case, the filter ",(0,s.jsx)(t.code,{children:"order.updated.>"})," would match only the old version, while ",(0,s.jsx)(t.code,{children:"v2.order.updated.>"})," would match only the new one."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Furthermore, if your business grows and expands to multiple regions, you can organize your subjects by region. For example, you could define subjects like ",(0,s.jsx)(t.code,{children:"ap-southeast-1.order.created"})," and ",(0,s.jsx)(t.code,{children:"ap-southeast-2.order.created"}),", along with regional versions like ",(0,s.jsx)(t.code,{children:"ap-southeast-1.v2.order.created "}),"and ",(0,s.jsx)(t.code,{children:"ap-southeast-2.v2.order.created"}),". This kind of flexibility allows you to organize and filter events in a way that suits the evolving structure of your business and its operational needs."]}),"\n",(0,s.jsxs)(t.h3,{id:"the-body",children:["The ",(0,s.jsx)(t.code,{children:"Body"})]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"Body"})," of an event is another important part of its structure. It is essentially an arbitrary byte array where you can store any kind of data you need. In most cases, developers use the ",(0,s.jsx)(t.code,{children:"Body"})," field to store a JSON string, which represents structured data about the event. However, you are not limited to JSON; the ",(0,s.jsx)(t.code,{children:"Body"})," field can also be used to store binary data, such as images, or even encoded or encrypted data, depending on your use case."]}),"\n",(0,s.jsx)(t.p,{children:"For example, you may choose to encrypt the data stored in the event body before saving it to the database. This approach ensures the security of your event data and can be useful in situations where sensitive information is involved. The data can then be decrypted when the event is consumed."}),"\n",(0,s.jsx)(t.p,{children:"Here's an example of how you might encrypt the body of an event:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'// pseudo code for demonstration\n\nbody, err := encrypt(...)\nif err !=nil {\n  log.Fatal(err)\n}\nevents := []*entities.Event{\n  entities.NewEvent("system.say_goodbye", body)),\n}\npub.Send(ctx, events)\n\n// Decrypt the data when receiving the event\nsub.Receive(ctx, func(ctx context.Context, msg *entities.Message) error {\n  data, err := decrypt(msg.Event.Body)\n  if err !=nil {\n    log.Fatal(err)\n  }\n\n  // Work with your decrypted data here\n})\n'})}),"\n",(0,s.jsxs)(t.p,{children:["This flexibility in handling the ",(0,s.jsx)(t.code,{children:"Body"})," of an event makes KanthorQ adaptable to a wide range of use cases, whether you need to work with simple JSON strings or more complex binary data formats."]}),"\n",(0,s.jsx)(t.h3,{id:"other-properties",children:"Other properties"}),"\n",(0,s.jsxs)(t.p,{children:["In addition to the ",(0,s.jsx)(t.code,{children:"Subject"})," and ",(0,s.jsx)(t.code,{children:"Body"})," fields, events in KanthorQ have other properties that serve specific purposes:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"Metadata"}),": This is an arbitrary map that can store additional information about the event. You can use this field to add any custom data related to the event. For instance, KanthorQ itself uses the ",(0,s.jsx)(t.code,{children:"Metadata"})," field to store telemetry tracing information, which helps track the flow of events within distributed systems."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"Id"}),": The ",(0,s.jsx)(t.code,{children:"Id"})," field is a unique identifier for the event and plays a critical role in KanthorQ. It serves as both the primary key and the partition key within the event stream. This identifier must be lexicographically sortable, meaning the order in which events are inserted can be determined by their IDs. To ensure this, KanthorQ uses ",(0,s.jsx)(t.a,{href:"https://github.com/ulid/spec",children:"ULID"})," as the default method for generating event IDs, but other options are also available, such as ",(0,s.jsx)(t.a,{href:"https://github.com/segmentio/ksuid",children:"KSUID"}),". However, ULID is preferred because it offers better guarantees for maintaining the correct order of events."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"inserting-events-basic-way",children:"Inserting Events (Basic Way)"}),"\n",(0,s.jsx)(t.p,{children:"To make event publishing easier, KanthorQ provides helper methods that simplify the process of initializing both the publisher and the event itself."}),"\n",(0,s.jsx)(t.p,{children:"When initializing a publisher, you must define two key options:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"Connection"}),": This is the connection string for the PostgreSQL database where events will be stored. You should replace this with the appropriate URI for your database."]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"StreamName"}),": This is the name of the stream in which you want to store your events. It\u2019s akin to the concept of a stream in ",(0,s.jsx)(t.a,{href:"https://docs.nats.io/nats-concepts/jetstream/streams",children:"NATS JetStream Streams"})," or an exchange in ",(0,s.jsx)(t.a,{href:"https://www.rabbitmq.com/tutorials/tutorial-three-go#exchanges",children:"RabbitMQ Exchange"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'options := &publisher.Options{\n  Connection: "postgres://postgres:changemenow@localhost:5432/postgres?sslmode=disable",\n  // Using default stream for demo\n  StreamName: entities.DefaultStreamName, // Using the default stream for this example\n}\n// Initialize the publisher\npub, cleanup := kanthorq.Pub(ctx, options)\n// Clean up the publisher after you\'re done\ndefer cleanup()\n'})}),"\n",(0,s.jsxs)(t.p,{children:["To initialize an event, you only need to define the ",(0,s.jsx)(t.code,{children:"Subject"})," and ",(0,s.jsx)(t.code,{children:"Body"}),". If you're using KanthorQ's helper methods, this process becomes even simpler. The ",(0,s.jsx)(t.code,{children:"NewEvent"})," method can be used to create a new event, where the ",(0,s.jsx)(t.code,{children:"Subject"})," describes the type of event, and the ",(0,s.jsx)(t.code,{children:"Body"})," contains the event data (typically in JSON format)."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'subject := "system.say_hello"\nbody := []byte("{\\"msg\\": \\"Hello World!\\"}")\nevent := entities.NewEvent(subject, body)\n\n// Add some additional metadata to the event\nevent.Metadata["version"] = "2"\nevent.Metadata["traceparent"] = "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"\n'})}),"\n",(0,s.jsx)(t.p,{children:"Now, you can bring everything together by publishing the event:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'options := &publisher.Options{\n  Connection: "postgres://postgres:changemenow@localhost:5432/postgres?sslmode=disable",\n  StreamName: entities.DefaultStreamName,\n}\npub, cleanup := kanthorq.Pub(ctx, options)\ndefer cleanup()\n\nsubject := "system.say_hello"\nbody := []byte("{\\"msg\\": \\"Hello World!\\"}")\nevent := entities.NewEvent(subject, body)\nevent.Metadata["version"] = "2"\nevent.Metadata["traceparent"] = "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"\n\nevents := []*entities.Event{event}\nif err:= pub.Send(ctx, events); err != nil {\n  // Handle any errors that occur during event publishing\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"This is the basic process for inserting events into KanthorQ. It's simple but effective, allowing you to get up and running quickly."}),"\n",(0,s.jsx)(t.h2,{id:"inserting-events-transactional-way",children:"Inserting Events (Transactional Way)"}),"\n",(0,s.jsx)(t.p,{children:"One of the most powerful features of KanthorQ is its ability to handle event publishing in a transactional manner. This means you can ensure that events are only published if the entire transaction is successful. This feature is especially useful in scenarios where you need consistency between your business logic and event publishing."}),"\n",(0,s.jsx)(t.p,{children:"For example, if you're updating an order in your system, you want to ensure that the order update and the event publication both either succeed or fail together. With transactional publishing, you can guarantee that no event is published unless the corresponding database transaction completes successfully."}),"\n",(0,s.jsx)(t.p,{children:"Here\u2019s how you can insert events transactionally:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'options := &publisher.Options{\n  Connection: "postgres://postgres:changemenow@localhost:5432/postgres?sslmode=disable",\n  StreamName: entities.DefaultStreamName,\n}\npub, cleanup := kanthorq.Pub(ctx, options)\ndefer cleanup()\n\nsubject := "order.updated"\nbody := []byte("{\\"txn_id\\": \\"afe86f5d-66a0-49ca-8c18-fbea71dc2a98\\"}")\nevent := entities.NewEvent(subject, body)\nevent.Metadata["traceparent"] = "00-80e1afed08e019fc1110464cfa66635c-7a085853722dc6d2-01"\n\nevents := []*entities.Event{event}\n\n// ------------ THE DIFFERENT IS HERE ---------\n// Start a new transaction\nconn, err := pgx.Connect(ctx, cm.uri)\nif err != nil {\n  return nil, err\n}\ntx, err := conn.BeginTx(ctx, pgx.TxOptions{})\nif err != nil {\n  return nil, err\n}\n\n// Publish events transactionally\nif err:= pub.SendTx(ctx, events, tx); err != nil {\n  // Handle any errors that occur during transactional publishing\n}\n\n// Do whatever you need to do with the transaction\n// call tx.Rollback(ctx) to abort the transaction\n\n// Commit the transaction\nif err := tx.Commit(ctx); err != nil {\n  // Handle commit error\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"This code ensures that events are only published if the transaction completes successfully. If the transaction fails, the events will not be inserted into the stream. This feature provides a higher level of consistency and reliability in your event-driven system."}),"\n",(0,s.jsxs)(t.p,{children:["For more details and examples, refer to our full documentation on the ",(0,s.jsx)(t.a,{href:"https://github.com/kanthorlabs/kanthorq/blob/main/example/transactional-publisher/main.go",children:"Transactional Publisher"})]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(6540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);