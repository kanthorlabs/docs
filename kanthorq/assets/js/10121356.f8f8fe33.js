"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9428],{9390:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var o=n(4848),s=n(8453);const r={title:"Subscriber",sidebar_label:"Subscriber",sidebar_position:7},a=void 0,i={id:"concepts/subscriber",title:"Subscriber",description:"The Subscriber is the most complicated component in KanthorQ system, but that complexity serves only one purpose: get your a task to work on it then try to get your task moves to Final State. If something went wrong with your task, you can ask for retry both manually or automatically from the Subscriber.",source:"@site/docs/002-concepts/007-subscriber.md",sourceDirName:"002-concepts",slug:"/concepts/subscriber",permalink:"/kanthorq/docs/concepts/subscriber",draft:!1,unlisted:!1,editUrl:"https://github.com/kanthorlabs/kanthorq/tree/main/packages/create-docusaurus/templates/shared/docs/002-concepts/007-subscriber.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{title:"Subscriber",sidebar_label:"Subscriber",sidebar_position:7},sidebar:"default",previous:{title:"Consumer",permalink:"/kanthorq/docs/concepts/consumer"},next:{title:"Advanced",permalink:"/kanthorq/docs/category/advanced"}},l={},c=[{value:"Workflows",id:"workflows",level:2},{value:"The Pulling Workflow",id:"the-pulling-workflow",level:3},{value:"The Updating Workflow",id:"the-updating-workflow",level:3}];function u(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["The Subscriber is the most complicated component in KanthorQ system, but that complexity serves only one purpose: get your a task to work on it then try to get your task moves to ",(0,o.jsx)(t.strong,{children:"Final State"}),". If something went wrong with your task, you can ask for retry both manually or automatically from the Subscriber."]}),"\n",(0,o.jsx)(t.h2,{id:"workflows",children:"Workflows"}),"\n",(0,o.jsx)(t.p,{children:"The Subscriber workflows will contains two parts: the pulling workflow that help you get tasks for your works and the updating workflow that help you update your task state after you have done with it"}),"\n",(0,o.jsx)(t.h3,{id:"the-pulling-workflow",children:"The Pulling Workflow"}),"\n",(0,o.jsx)(t.mermaid,{value:"---\ntitle: The Pulling Workflow\n---\nsequenceDiagram\n  Subscriber ->> +Consumer Registry: name: send_cancellation_email\n\n  rect rgb(191, 223, 255)\n  note right of Subscriber: Transaction Box\n\n  Consumer Registry ->> -kanthorq_stream_order_update: topic: order.cancelled, cursor: evt_01J36ZJACKR5FXDWVKASC4BNCN, limit: 100\n\n  loop 100 events or timeout\n    kanthorq_stream_order_update --\x3e> kanthorq_stream_order_update: scanning\n    kanthorq_stream_order_update ->> +send_cancellation_email: events\n    send_cancellation_email --\x3e> -send_cancellation_email: convert events to tasks\n  end\n\n  send_cancellation_email --\x3e> +Subscriber: 100 tasks\n  Subscriber ->> -Consumer Registry: next_cursor: evt_01J3702FVA6EJ7QB7CNRMCP93B\n\n  end"}),"\n",(0,o.jsxs)(t.p,{children:["Not like Publish only works with one component - the Stream, the Subscriber needs to interact with two components: the Stream and the Consumer. It will work with the Stream to help convert events from a stream to a task in a consumer, then it pulls those tasks for you. The ",(0,o.jsx)(t.em,{children:"Transaction Box"})," indicates that all actions will be run in a transcation, so that we can guarantee pulling a task exactly once."]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"We will start with a request to ask for 100 tasks."}),"\n",(0,o.jsx)(t.li,{children:"We need to work with the Consumer Registry to get a stream name, a topic and a cursor of previous scanning in the Stream. If the scan does not receive enough events, we need to perform it again until we reach maximum waiting time of the scan."}),"\n",(0,o.jsx)(t.li,{children:"Put all parameters together we will scan the Stream to look for matching events with given topic."}),"\n",(0,o.jsx)(t.li,{children:"After events are found, we start converting those events to tasks by inserting them into our Consumer then return those tasks back to our Subscriber."}),"\n",(0,o.jsx)(t.li,{children:"Because a task is belong to only one event, so we also know what is the next cursor is (the latest task contains the latest matching event), so we need to update that cursor back to our Consumer Registry"}),"\n",(0,o.jsx)(t.li,{children:"Countinue the loop until we get termination sinal"}),"\n"]}),"\n",(0,o.jsxs)(t.admonition,{type:"info",children:[(0,o.jsxs)(t.p,{children:["By saying ",(0,o.jsx)(t.strong,{children:"scanning"}),", we mean we will query events from a stream from the lower bound that is specify by the ",(0,o.jsx)(t.strong,{children:"cursor"})," until we get enough rows (100 events). The simplify query will look like"]}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sql",children:"SELECT * FROM kanthorq_stream_order_update WHERE id > 'evt_01J36ZJACKR5FXDWVKASC4BNCN' LIMIT 100\n"})})]}),"\n",(0,o.jsx)(t.h3,{id:"the-updating-workflow",children:"The Updating Workflow"}),"\n",(0,o.jsxs)(t.p,{children:["After finished your works, you need to report back to the Subscriber what state of a task should be updated to. For example, there are two main states you want the Subscriber to update: ",(0,o.jsx)(t.code,{children:"Completed"})," and ",(0,o.jsx)(t.code,{children:"Retryable"})," for succeed task and error task respectively. But there are some situation you don't want to let error task to be retried, so you want to mark that task as ",(0,o.jsx)(t.code,{children:"Cancelled"})]}),"\n",(0,o.jsx)(t.admonition,{type:"tip",children:(0,o.jsxs)(t.p,{children:["Checkout our definition about ",(0,o.jsx)(t.a,{href:"/kanthorq/docs/concepts/task#task-state",children:"Task State"})," to see how many state do we have and what categories they are."]})}),"\n",(0,o.jsx)(t.mermaid,{value:"---\ntitle: The Updating Workflow\n---\nsequenceDiagram\n  Subscriber ->> +Handler: 100 events\n  Handler --\x3e> -Handler: execute 100 events\n  Handler --\x3e> +Subscriber: 83 succeed tasks\n  Subscriber ->> Consumer: mark as completed 83 tasks\n  Handler --\x3e> Subscriber: 17 error tasks\n  Subscriber ->> Consumer: mark as retryable 17 tasks"}),"\n",(0,o.jsxs)(t.admonition,{type:"danger",children:[(0,o.jsx)(t.p,{children:"If you plan to update the state by yourself (common, it's just a PostgreSQL query and you can totally do it by yourslef), make sure you keep in mind that you should only move a task from state-A to state-B, not override the task to state B"}),(0,o.jsx)(t.p,{children:"Example:"}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"# no supprise, if task does not in state-A, nothing will be updated\ntask:state-A -> task:state-B\n\n# if concurrency updating happen at the same time, [Lost Update](https://en.wikipedia.org/wiki/Concurrency_control) will happen\ntask -> task:state-B\n\n# three updates bellow are executed at the same time, then you will lost update of two tasks and does not know about it to rollback if it's necessary\ntask:state-A -> task:state-B\ntask:state-X -> task:state-B\ntask:state-Y -> task:state-B\n"})})]})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var o=n(6540);const s={},r=o.createContext(s);function a(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);