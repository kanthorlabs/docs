"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9804],{6948:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var r=t(4848),o=t(8453),s=t(1470),a=t(9365);const i={title:"Consumer",sidebar_label:"Consumer",sidebar_position:4},c=void 0,l={id:"concepts/consumer",title:"Consumer",description:"Consumer is a topic specific filter of events from a stream what stores metadata about how we want to process those events. One consumer can only subscribe to one topic but we can have more than one consumer for only one topic.",source:"@site/docs/concepts/004-consumer.md",sourceDirName:"concepts",slug:"/concepts/consumer",permalink:"/kanthorq/docs/concepts/consumer",draft:!1,unlisted:!1,editUrl:"https://github.com/kanthorlabs/kanthorq/tree/main/packages/create-docusaurus/templates/shared/docs/concepts/004-consumer.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Consumer",sidebar_label:"Consumer",sidebar_position:4},sidebar:"default",previous:{title:"Task",permalink:"/kanthorq/docs/concepts/task"},next:{title:"Advanced",permalink:"/kanthorq/docs/category/advanced"}},u={},d=[{value:"Manage consumers",id:"manage-consumers",level:2},{value:"Consumer Registry",id:"consumer-registry",level:3},{value:"Consumer",id:"consumer",level:3}];function m(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Consumer is a topic specific filter of events from a stream what stores metadata about how we want to process those events. One consumer can only subscribe to one topic but we can have more than one consumer for only one topic."}),"\n",(0,r.jsxs)(n.p,{children:["For example, with the topic ",(0,r.jsx)(n.code,{children:"order.confirmed"})," we may want to spin up two consumer: one for sending notification via email to user to nofiy user that their order is confirmed and another consumer to handle logic of showing that order in a CRM so seller can prepare to ship that order"]}),"\n",(0,r.jsx)(n.mermaid,{value:"---\ntitle: subscriber\n---\nflowchart TB\n  order_update[(kanthor_stream_order_update)] -- order.confirmed  --\x3e Consumer_1[Send Confirm Email]\n  order_update[(kanthor_stream_order_update)] -- order.confirmed  --\x3e Consumer_2[Sync CRM Order]\n  order_update[(kanthor_stream_order_update)] -- order.refund  ---\x3e Consumer_3[Send Refund Email]"}),"\n",(0,r.jsx)(n.h2,{id:"manage-consumers",children:"Manage consumers"}),"\n",(0,r.jsx)(n.p,{children:"Like stream, when you create or register a consumer, its information will be store in a registry before KanthorQ creates an acutal consumer to store tasks to process later"}),"\n",(0,r.jsx)(n.mermaid,{value:"---\ntitle: Consumer Register Flow\n---\nsequenceDiagram\n  Client ->> +Consumer Registry: name: send_confirmed_email, topic: order.confirmed\n  Consumer Registry --\x3e> -Client: Consumer(name: send_confirmed_email, topic: order.confirmed)\n\n  Client ->> +PostgreSQL: kanthorq_consumer_send_confirmed_email\n  PostgreSQL --\x3e> -Client: OK"}),"\n",(0,r.jsx)(n.h3,{id:"consumer-registry",children:"Consumer Registry"}),"\n",(0,r.jsxs)(n.p,{children:["There is the definition of the ",(0,r.jsx)(n.code,{children:"Consumer Registry"})," in different places in KanthorQ"]}),"\n",(0,r.jsxs)(s.A,{children:[(0,r.jsx)(a.A,{value:"go",label:"Go",default:!0,children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'type ConsumerRegistry struct {\n    StreamName string `json:"stream_name"`\n    Name       string `json:"name"`\n    Topic      string `json:"topic"`\n    Cursor     string `json:"cursor"`\n    AttemptMax int16  `json:"attempt_max"`\n    CreatedAt  int64  `json:"created_at"`\n    UpdatedAt  int64  `json:"updated_at"`\n}\n'})})}),(0,r.jsx)(a.A,{value:"postgresql",label:"PostgreSQL",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"TABLE kanthorq_consumer_registry (\n    name VARCHAR(128) NOT NULL,\n    stream_name VARCHAR(128) NOT NULL,\n    topic VARCHAR(128) NOT NULL,\n    cursor VARCHAR(64) NOT NULL,\n    attempt_max SMALLINT NOT NULL DEFAULT 3,\n    created_at BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) * 1000,\n    updated_at BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) * 1000,\n    PRIMARY KEY (name)\n)\n"})})})]}),"\n",(0,r.jsx)(n.p,{children:"Not like stream, consumer registry contains some runtime configuration that control how a consumer should handle their tasks."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"cursor"}),": When a consumer is registred, it will be empty. But after any execution, ",(0,r.jsx)(n.code,{children:"cursor"})," is the ",(0,r.jsx)(n.code,{children:"id"})," property of the latest event we can pull out of stream with ",(0,r.jsx)(n.code,{children:"topic"})," filter. For example, after the first execution with topic ",(0,r.jsx)(n.code,{children:"order.created"}),", the latest id we can retrieve is ",(0,r.jsx)(n.code,{children:"id_10"}),", next execution will always take the filter that ",(0,r.jsx)(n.code,{children:"id > id_10"})," as the condition to filter our already processed events or tasks"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"attempt_max"})," control how many attempt we want to do before give up on error tasks."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"consumer",children:"Consumer"}),"\n",(0,r.jsxs)(n.p,{children:["A consumer itself store a group of tasks that are generated from events in a stream. If your stream ",(0,r.jsx)(n.code,{children:"kanthorq_stream_order_update"})," has 999 events of topic ",(0,r.jsx)(n.code,{children:"order.confirmed"})," and you have a consumer ",(0,r.jsx)(n.code,{children:"kanthorq_consumer_registry"})," that subscribed to the event, you will have 999 tasks inside the consumer names ",(0,r.jsx)(n.code,{children:"kanthorq_consumer_send_confirmed_email"})]}),"\n",(0,r.jsx)(n.p,{children:"So when you want to get a list of tasks for your subscriber, you need to perform two action"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Generate a list of tasks for your consumer for matching events of consumer topic"}),"\n",(0,r.jsx)(n.li,{children:"Pull out what tasks you have generated before with its information"}),"\n"]}),"\n",(0,r.jsx)(n.mermaid,{value:'---\ntitle: Consumer Pull Flow\n---\nsequenceDiagram\nautonumber\n  loop Pulling\n    Client ->> +Consumer Registry: name: send_confirmed_email\n    Consumer Registry --\x3e> -Client: topic: order.confirmed, cursor: ""\n    Client ->> +kanthorq_stream_order_update: topic: order.confirmed, cursor: ""\n    kanthorq_stream_order_update ->> kanthorq_consumer_send_confirmed_email: 100 events\n    kanthorq_consumer_send_confirmed_email ->> kanthorq_consumer_send_confirmed_email: 100 tasks\n    kanthorq_consumer_send_confirmed_email --\x3e> Client: 100 tasks\n  end'}),"\n",(0,r.jsxs)(n.p,{children:["If definition of ",(0,r.jsx)(n.code,{children:"Stream"})," is as same as ",(0,r.jsx)(n.code,{children:"Event"}),", definition of ",(0,r.jsx)(n.code,{children:"Consumer"})," is as same as ",(0,r.jsx)(n.code,{children:"Task"})," because ",(0,r.jsx)(n.code,{children:"Consumer"})," is where we store metadata of how we will execute an event, aka a task"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sql",children:"TABLE kanthorq_consumer_send_confirmed_email (\n\tevent_id VARCHAR(64) NOT NULL,\n\ttopic VARCHAR(128) NOT NULL,\n\tstate SMALLINT NOT NULL DEFAULT 1,\n\tschedule_at BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) * 1000,\n\tfinalized_at BIGINT NOT NULL DEFAULT 0,\n\tattempt_count SMALLINT NOT NULL DEFAULT 0,\n\tattempted_at BIGINT NOT NULL DEFAULT 0,\n\tcreated_at BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) * 1000,\n\tupdated_at BIGINT NOT NULL DEFAULT EXTRACT(EPOCH FROM CURRENT_TIMESTAMP) * 1000,\n\tPRIMARY KEY (event_id)\n)\n"})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},9365:(e,n,t)=>{t.d(n,{A:()=>a});t(6540);var r=t(4164);const o={tabItem:"tabItem_Ymn6"};var s=t(4848);function a(e){let{children:n,hidden:t,className:a}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,r.A)(o.tabItem,a),hidden:t,children:n})}},1470:(e,n,t)=>{t.d(n,{A:()=>j});var r=t(6540),o=t(4164),s=t(3104),a=t(6347),i=t(205),c=t(7485),l=t(1682),u=t(679);function d(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function m(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=n??function(e){return d(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:o}}=e;return{value:n,label:t,attributes:r,default:o}}))}(t);return function(e){const n=(0,l.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function h(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function p(e){let{queryString:n=!1,groupId:t}=e;const o=(0,a.W6)(),s=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,c.aZ)(s),(0,r.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(o.location.search);n.set(s,e),o.replace({...o.location,search:n.toString()})}),[s,o])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:o}=e,s=m(e),[a,c]=(0,r.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!h({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const r=t.find((e=>e.default))??t[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:s}))),[l,d]=p({queryString:t,groupId:o}),[f,_]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[o,s]=(0,u.Dv)(t);return[o,(0,r.useCallback)((e=>{t&&s.set(e)}),[t,s])]}({groupId:o}),b=(()=>{const e=l??f;return h({value:e,tabValues:s})?e:null})();(0,i.A)((()=>{b&&c(b)}),[b]);return{selectedValue:a,selectValue:(0,r.useCallback)((e=>{if(!h({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);c(e),d(e),_(e)}),[d,_,s]),tabValues:s}}var _=t(2303);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var x=t(4848);function g(e){let{className:n,block:t,selectedValue:r,selectValue:a,tabValues:i}=e;const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,s.a_)(),u=e=>{const n=e.currentTarget,t=c.indexOf(n),o=i[t].value;o!==r&&(l(n),a(o))},d=e=>{let n=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const t=c.indexOf(e.currentTarget)+1;n=c[t]??c[0];break}case"ArrowLeft":{const t=c.indexOf(e.currentTarget)-1;n=c[t]??c[c.length-1];break}}n?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.A)("tabs",{"tabs--block":t},n),children:i.map((e=>{let{value:n,label:t,attributes:s}=e;return(0,x.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:e=>c.push(e),onKeyDown:d,onClick:u,...s,className:(0,o.A)("tabs__item",b.tabItem,s?.className,{"tabs__item--active":r===n}),children:t??n},n)}))})}function v(e){let{lazy:n,children:t,selectedValue:o}=e;const s=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=s.find((e=>e.props.value===o));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:s.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==o})))})}function T(e){const n=f(e);return(0,x.jsxs)("div",{className:(0,o.A)("tabs-container",b.tabList),children:[(0,x.jsx)(g,{...n,...e}),(0,x.jsx)(v,{...n,...e})]})}function j(e){const n=(0,_.A)();return(0,x.jsx)(T,{...e,children:d(e.children)},String(n))}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var r=t(6540);const o={},s=r.createContext(o);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);