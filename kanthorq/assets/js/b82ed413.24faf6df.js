"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[542],{1429:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var s=n(4848),o=n(8453);const a={title:"Insert events",sidebar_label:"Insert events",sidebar_position:1},r=void 0,i={id:"guides/insert-events",title:"Insert events",description:"The first step at a journey of working with KanthorQ is inserting events into KanthorQ system. So that it will be there for you to handle it later forever (until you delete it). To insert events into KanthorQ system, you need to know the structure of the events in KanthorQ system firstly. Then I will show you how to insert events in a basic way and in transactional way.",source:"@site/docs/002-guides/001-insert-events.md",sourceDirName:"002-guides",slug:"/guides/insert-events",permalink:"/kanthorq/docs/guides/insert-events",draft:!1,unlisted:!1,editUrl:"https://github.com/kanthorlabs/kanthorq/tree/main/packages/create-docusaurus/templates/shared/docs/002-guides/001-insert-events.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Insert events",sidebar_label:"Insert events",sidebar_position:1},sidebar:"default",previous:{title:"Guides",permalink:"/kanthorq/docs/category/guides"},next:{title:"Process events and tasks",permalink:"/kanthorq/docs/guides/process-events-and-tasks"}},d={},l=[{value:"The event structure",id:"the-event-structure",level:2},{value:"The <code>Subject</code>",id:"the-subject",level:3},{value:"The <code>Body</code>",id:"the-body",level:3},{value:"Other properties",id:"other-properties",level:3},{value:"Insert events in a basic way",id:"insert-events-in-a-basic-way",level:2},{value:"Insert events in a transactional way",id:"insert-events-in-a-transactional-way",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"The first step at a journey of working with KanthorQ is inserting events into KanthorQ system. So that it will be there for you to handle it later forever (until you delete it). To insert events into KanthorQ system, you need to know the structure of the events in KanthorQ system firstly. Then I will show you how to insert events in a basic way and in transactional way."}),"\n",(0,s.jsx)(t.h2,{id:"the-event-structure",children:"The event structure"}),"\n",(0,s.jsxs)(t.p,{children:["The representation of an event in KanthorQ system is shown below. The most common properties you will work with a lots later are the ",(0,s.jsx)(t.code,{children:"Subject"})," and the ",(0,s.jsx)(t.code,{children:"Body"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'type Event struct {\n  Id        string   `json:"id" validate:"required"`\n  Subject   string   `json:"subject" validate:"required,is_subject"`\n  Body      []byte   `json:"body" validate:"required"`\n  Metadata  Metadata `json:"metadata" validate:"required"`\n  CreatedAt int64    `json:"created_at"`\n}\n'})}),"\n",(0,s.jsxs)(t.h3,{id:"the-subject",children:["The ",(0,s.jsx)(t.code,{children:"Subject"})]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"Subject"})," is a property that allows you organize your events in a hierarchical structure. I borrowed it from ",(0,s.jsx)(t.a,{href:"https://docs.nats.io/nats-concepts/subjects",children:"NATS Subject-Based Messaging"}),". If you are familiar with RabbitMQ, you can think it's kind of ",(0,s.jsx)(t.a,{href:"https://www.rabbitmq.com/tutorials/tutorial-five-go#topic-exchange",children:"Routing Key"})]}),"\n",(0,s.jsxs)(t.p,{children:["Lets say you need to work with event of order that is updated, you can define a subject like this ",(0,s.jsx)(t.code,{children:"order.updated"}),". Then you can write your own logic to handle it."]}),"\n",(0,s.jsx)(t.p,{children:"After a period of time, your business requirements may change and you need another logic to handle the event that is belong. Then you have to decide whether you should modify the old logic to support the new version of just write another completely logic to handle new version."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["If you decide to support both old and new logic, you can define a new subject like this ",(0,s.jsx)(t.code,{children:"order.updated.v2"})," so you can filter all events that match both the old and new version with the filter ",(0,s.jsx)(t.code,{children:"order.updated.>"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["If you choose the other soluton, you can define a new subject like this ",(0,s.jsx)(t.code,{children:"v2.order.updated"})," so that the filter ",(0,s.jsx)(t.code,{children:"order.updated.>"})," will only match the old one, and ",(0,s.jsx)(t.code,{children:"v2.order.updated.>"})," only match the new one. Then you can register an other subscriber to working on the filter ",(0,s.jsx)(t.code,{children:"v2.order.updated.>"})]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Later, you got a bump, your business grows rapidly and you decide that you need to support multiple regions. Then you can define another subject like this ",(0,s.jsx)(t.code,{children:"ap-southeast-1.order.created"}),", ",(0,s.jsx)(t.code,{children:"ap-southeast-2.order.created"}),", ",(0,s.jsx)(t.code,{children:"ap-southeast-1.v2.order.created"})," and ",(0,s.jsx)(t.code,{children:"ap-southeast-2.v2.order.created"})]}),"\n",(0,s.jsxs)(t.h3,{id:"the-body",children:["The ",(0,s.jsx)(t.code,{children:"Body"})]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"body"})," is an arbitrary byte array that you can use to store any data you want. Most commone usage are json string, but you can also use image binary or base64 as well. And other example usage is you encrypt the ",(0,s.jsx)(t.code,{children:"body"})," in the event before it's stored in the database. Then you can decrypt it when you need it."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'// pseudo code for demonstration\n\nbody, err := encrypt(...)\nif err !=nil {\n  log.Fatal(err)\n}\nevents := []*entities.Event{\n  entities.NewEvent("system.say_goodbye", body)),\n}\npub.Send(ctx, events)\n\n// other logic\n\nsub.Receive(ctx, func(ctx context.Context, msg *entities.Message) error {\n  data, err := decrypt(msg.Event.Body)\n  if err !=nil {\n    log.Fatal(err)\n  }\n\n  // working with your data here\n})\n'})}),"\n",(0,s.jsx)(t.h3,{id:"other-properties",children:"Other properties"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"Metadata"})," is an arbitrary map that you can use to store additional information about your event. For example, KanthorQ will use it to store the Telemetry Tracing information"]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"Id"})," is the most important property of an event but I think you should not touch it. It's a primary key as well as parition key of the stream. We use it to scan through the stream to get events so it must be lexicographically sortable. Some candidates that can be use here is"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Our choice is ",(0,s.jsx)(t.a,{href:"https://github.com/ulid/spec",children:"ULID"})]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"https://github.com/segmentio/ksuid",children:"KSUID"}),". Uses UNIX-time in seconds, if your insert rate is about 1000 events per second, you loose the order of your inserting events."]}),"\n",(0,s.jsx)(t.li,{children:"Auto-increment ID of Postgres. Not unique if you try to looking in different streams as well as not available until you inserted it successfully."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"insert-events-in-a-basic-way",children:"Insert events in a basic way"}),"\n",(0,s.jsx)(t.p,{children:"To make your coding experience a lot easier, I have define some facade methods to help you initialize both the publisher and event"}),"\n",(0,s.jsx)(t.p,{children:"To intialize the publisher, you must define two options:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.code,{children:"Connection"})," is the connection string of PostgreSQl database"]}),"\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)(t.code,{children:"StreamName"})," is the name of the stream you want to store events. Think about ",(0,s.jsx)(t.a,{href:"https://docs.nats.io/nats-concepts/jetstream/streams",children:"NATS JetStream Streams"})," or ",(0,s.jsx)(t.a,{href:"https://www.rabbitmq.com/tutorials/tutorial-three-go#exchanges",children:"RabbitMQ Exchange"})]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'options := &publisher.Options{\n  // replace connection string with your database URI\n  Connection: "postgres://postgres:changemenow@localhost:5432/postgres?sslmode=disable",\n  // using default stream for demo\n  StreamName: entities.DefaultStreamName,\n}\n// Initialize a publisher\npub, cleanup := kanthorq.Pub(ctx, options)\n// clean up the publisher after everything is done\ndefer cleanup()\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Initialize an event is easier, you only need to define the ",(0,s.jsx)(t.code,{children:"Subject"})," and ",(0,s.jsx)(t.code,{children:"Body"})," if you use the facade method ",(0,s.jsx)(t.code,{children:"NewEvent"})]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'subject := "system.say_hello"\nbody := []byte("{\\"msg\\": \\"Hello World!\\"}")\nevent := entities.NewEvent(subject, body)\n// add some additional metadata\nevent.Metadata["version"] = "2"\nevent.Metadata["traceparent"] = "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"\n'})}),"\n",(0,s.jsx)(t.p,{children:"Bring them up together, we will have a pseudo code like this"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'options := &publisher.Options{\n  // replace connection string with your database URI\n  Connection: "postgres://postgres:changemenow@localhost:5432/postgres?sslmode=disable",\n  // using default stream for demo\n  StreamName: entities.DefaultStreamName,\n}\n// Initialize a publisher\npub, cleanup := kanthorq.Pub(ctx, options)\n// clean up the publisher after everything is done\ndefer cleanup()\n\nsubject := "system.say_hello"\nbody := []byte("{\\"msg\\": \\"Hello World!\\"}")\nevent := entities.NewEvent(subject, body)\n// add some additional metadata\nevent.Metadata["version"] = "2"\nevent.Metadata["traceparent"] = "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"\n\n// publish events\nevents := []*entities.Event{event}\nif err:= pub.Send(ctx, events); err != nil {\n  // handle error\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"insert-events-in-a-transactional-way",children:"Insert events in a transactional way"}),"\n",(0,s.jsx)(t.p,{children:"One of the coolest features we have at KanthorQ is you can publish events in a transactional way. That means you can garantee that your events are only published if and only if the whole transcation is success. Is it cool, right?"}),"\n",(0,s.jsx)(t.p,{children:"If you get back to the example before about the order events, you can realise that you can expect that both your updating and the event publishing are either success or failure. You will not be able to fall into a case that you publish an event success but your updating is failed or vice versa."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'options := &publisher.Options{\n  // replace connection string with your database URI\n  Connection: "postgres://postgres:changemenow@localhost:5432/postgres?sslmode=disable",\n  // using default stream for demo\n  StreamName: entities.DefaultStreamName,\n}\n// Initialize a publisher\npub, cleanup := kanthorq.Pub(ctx, options)\n// clean up the publisher after everything is done\ndefer cleanup()\n\nsubject := "system.say_hello"\nbody := []byte("{\\"msg\\": \\"Hello World!\\"}")\nevent := entities.NewEvent(subject, body)\n// add some additional metadata\nevent.Metadata["version"] = "2"\nevent.Metadata["traceparent"] = "00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01"\n\n// publish events\nevents := []*entities.Event{event}\n// ------------ THE DIFFERENT IS HERE ---------\n// start a different connection\nconn, err := pgx.Connect(ctx, cm.uri)\nif err != nil {\n  return nil, err\n}\ntx, err := conn.BeginTx(ctx, pgx.TxOptions{})\nif err != nil {\n  return nil, err\n}\n\nif err:= pub.SendTx(ctx, events, tx); err != nil {\n  // handle error\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["The full example can be found at our example of ",(0,s.jsx)(t.a,{href:"https://github.com/kanthorlabs/kanthorq/blob/main/example/transactional-publisher/main.go",children:"Transactional Publisher"})]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>i});var s=n(6540);const o={},a=s.createContext(o);function r(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);