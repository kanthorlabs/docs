"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3552],{7262:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var s=n(4848),r=n(8453);const i={title:"Working on events",sidebar_label:"Working on events",sidebar_position:2},o=void 0,a={id:"guides/working-on-events",title:"Working on events",description:"Every event will generated at least one task when you are working on it. Then, based on your expectation, you may need to work extra on that event to handle failure like retrying. In this article I will show you two ways to use subscriber to handle your tasks of your events. The first one is the most convivenient way. The second one gives your more control on how do you want to handle both happy case and failure case.",source:"@site/docs/002-guides/002-working-on-events.md",sourceDirName:"002-guides",slug:"/guides/working-on-events",permalink:"/kanthorq/docs/guides/working-on-events",draft:!1,unlisted:!1,editUrl:"https://github.com/kanthorlabs/kanthorq/tree/main/packages/create-docusaurus/templates/shared/docs/002-guides/002-working-on-events.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Working on events",sidebar_label:"Working on events",sidebar_position:2},sidebar:"default",previous:{title:"Insert events",permalink:"/kanthorq/docs/guides/insert-events"},next:{title:"Concepts",permalink:"/kanthorq/docs/category/concepts"}},l={},c=[{value:"Using subscriber facade",id:"using-subscriber-facade",level:2},{value:"Using subscriber directly",id:"using-subscriber-directly",level:2},{value:"Using the Primary Subscriber",id:"using-the-primary-subscriber",level:3},{value:"Using the Retry Subscriber",id:"using-the-retry-subscriber",level:3},{value:"Using the Availability Subscriber",id:"using-the-availability-subscriber",level:3}];function u(e){const t={admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"Every event will generated at least one task when you are working on it. Then, based on your expectation, you may need to work extra on that event to handle failure like retrying. In this article I will show you two ways to use subscriber to handle your tasks of your events. The first one is the most convivenient way. The second one gives your more control on how do you want to handle both happy case and failure case."}),"\n",(0,s.jsx)(t.h2,{id:"using-subscriber-facade",children:"Using subscriber facade"}),"\n",(0,s.jsx)(t.p,{children:"KanthorQ package provides you two facades, the first one is the publisher facade that you quickly intialize your publisher to help you insert your events into the KanthorQ system. Now let me introduce you to the second one - the subscriber facade that registers three types of subscribers:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The Primary Subscriber that handles up comming events in the system, produces tasks to execute your business logic."}),"\n",(0,s.jsx)(t.li,{children:"The Retry Subscriber that handles events that need retrying."}),"\n",(0,s.jsx)(t.li,{children:"The Visibility Subscriber that handles events that are visible in the system, aka stuck for a long time in the system exceeded the visibility timeout."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The example code is similar to the one in the quickstart article."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'import (\n  "context"\n  "errors"\n  "fmt"\n  "log"\n  "os"\n  "os/signal"\n  "syscall"\n  "time"\n\n  "github.com/kanthorlabs/kanthorq"\n  "github.com/kanthorlabs/kanthorq/entities"\n  "github.com/kanthorlabs/kanthorq/puller"\n  "github.com/kanthorlabs/kanthorq/subscriber"\n)\n\nfunc main() {\n  // listen for SIGTERM so if you press Ctrl-C you can stop the program\n  ctx, stop := signal.NotifyContext(context.TODO(), os.Interrupt, syscall.SIGINT, syscall.SIGTERM)\n  defer stop()\n\n  var options = &subscriber.Options{\n    // replace connection string with your database URI\n    Connection: "postgres://postgres:changemenow@localhost:5432/postgres?sslmode=disable",\n    // we use default stream for demo\n    StreamName: entities.DefaultStreamName,\n    // we use default consumer for demo\n    ConsumerName: entities.DefaultConsumerName,\n    // we will only receive events that match with the filter\n    // so both system.say_hello and system.say_goodbye will be processed\n    ConsumerSubjectIncludes: []string{"system.>"},\n    // if task is failed, it will be retried it with this number of times\n    ConsumerAttemptMax: entities.DefaultConsumerAttemptMax,\n    // if task is stuck, we will wait this amount of time to reprocess it\n    ConsumerVisibilityTimeout: entities.DefaultConsumerVisibilityTimeout,\n    Puller: puller.PullerIn{\n      // Size is how many events you want to pull at one batch\n      Size: 100,\n      // WaitingTime is how long you want to wait before finish current batch\n      // because you don\'t get enough events defined in the Size attribute\n      WaitingTime: 1000,\n    },\n  }\n\n  // hanlding events, the gorouting will be block until you press Ctrl-C\n  err := kanthorq.Sub(ctx, options, func(ctx context.Context, msg *subscriber.Message) error {\n    ts := time.UnixMilli(msg.Event.CreatedAt).Format(time.RFC3339)\n    // print out recevied event\n    fmt.Printf("RECEIVED: %s | %s | %s\\n", msg.Event.Id, msg.Event.Subject, ts)\n    return nil\n  })\n\n  // print out error if any\n  if err != nil && !errors.Is(err, context.Canceled) {\n    log.Fatal(err)\n  }\n}\n'})}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsx)(t.p,{children:"Because you are using the subscriber facade, so that the handle you given will be use for all of subscribers under the facade. That mean you will process tasks of new events, retrying events and handling events that are stuck for a long time with same logic by the given handler."})}),"\n",(0,s.jsx)(t.h2,{id:"using-subscriber-directly",children:"Using subscriber directly"}),"\n",(0,s.jsx)(t.p,{children:"There are some usecases that you want to execute your task differently for the new events or the retry ones. In this case, you can use the subscriber directly to sastify your needs."}),"\n",(0,s.jsx)(t.h3,{id:"using-the-primary-subscriber",children:"Using the Primary Subscriber"}),"\n",(0,s.jsx)(t.p,{children:"This subscriber need working on two things"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Scan through your stream to look for new events that match with the filter you set when registering the consumer that will be used by the subscriber"}),"\n",(0,s.jsx)(t.li,{children:"If there is new events, generate a task corresponding to that event, return both the task and the event to you so that you can execute it"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The example code bellow shows how to use the Primary Subscriber directly:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'import (\n  "context"\n  "errors"\n  "fmt"\n  "os"\n  "os/signal"\n  "syscall"\n  "time"\n\n  "github.com/kanthorlabs/kanthorq/entities"\n  "github.com/kanthorlabs/kanthorq/pkg/xlogger"\n  "github.com/kanthorlabs/kanthorq/puller"\n  "github.com/kanthorlabs/kanthorq/subscriber"\n  "go.uber.org/zap"\n)\n\nfunc main() {\n  // listen for SIGTERM so if you press Ctrl-C you can stop the program\n  ctx, stop := signal.NotifyContext(context.TODO(), os.Interrupt, syscall.SIGINT, syscall.SIGTERM)\n  defer stop()\n\n  logger := xlogger.New()\n\n  // options is same as the subscriber facade\n  var options = &subscriber.Options{\n    // replace connection string with your database URI\n    Connection: "postgres://postgres:changemenow@localhost:5432/postgres?sslmode=disable",\n    // we use default stream for demo\n    StreamName: entities.DefaultStreamName,\n    // we use default consumer for demo\n    ConsumerName: entities.DefaultConsumerName,\n    // we will only receive events that match with the filter\n    // so both system.say_hello and system.say_goodbye will be processed\n    ConsumerSubjectIncludes: []string{"system.>"},\n    // if task is failed, it will be retried it with this number of times\n    ConsumerAttemptMax: entities.DefaultConsumerAttemptMax,\n    // if task is stuck, we will wait this amount of time to reprocess it\n    ConsumerVisibilityTimeout: entities.DefaultConsumerVisibilityTimeout,\n    Puller: puller.PullerIn{\n      // Size is how many events you want to pull at one batch\n      Size: 100,\n      // WaitingTime is how long you want to wait before finish current batch\n      // because you don\'t get enough events defined in the Size attribute\n      WaitingTime: 1000,\n    },\n  }\n  sub, err := subscriber.New(options, logger)\n  if err != nil {\n    panic(err)\n  }\n\n  var timeout = time.Second * 3\n\n  // starting a subscriber should be use with timeout\n  startctx, cancel := context.WithTimeout(ctx, timeout)\n  defer cancel()\n  if err := sub.Start(startctx); err != nil {\n    panic(err)\n  }\n\n  defer func() {\n    // graceful shutdown starting\n    // don\'t reuse ctx here because it already done\n    // you also need timeout here\n    stopCtx, stopCancel := context.WithTimeout(context.Background(), timeout)\n    defer stopCancel()\n    if err := sub.Stop(stopCtx); err != nil {\n      logger.Error("subscriber stop with error", zap.Error(err))\n      return\n    }\n  }()\n\n  // the main part, working on up comming events and tasks\n  receiveCtx, receiveCancel := context.WithCancel(ctx)\n  defer receiveCancel()\n\n  // start receiving events and tasks\n  go func() {\n    err := sub.Receive(receiveCtx, func(ctx context.Context, msg *subscriber.Message) error {\n      ts := time.UnixMilli(msg.Event.CreatedAt).Format(time.RFC3339)\n      // print out recevied event\n      fmt.Printf("RECEIVED: %s | %s | %s\\n", msg.Event.Id, msg.Event.Subject, ts)\n      return nil\n    })\n\n    if err != nil && !errors.Is(err, context.Canceled) {\n      logger.Error("subscriber receive with error", zap.Error(err))\n    }\n\n    // subscriber is done, should cancel the context to trigger other workflows\n    receiveCancel()\n  }()\n\n  <-receiveCtx.Done()\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"using-the-retry-subscriber",children:"Using the Retry Subscriber"}),"\n",(0,s.jsx)(t.p,{children:"If a task of event is failed and you mark it as retryable, this subscriber will help you retry it. It will"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Transition the state of task from ",(0,s.jsx)(t.code,{children:"Retryable"})," to ",(0,s.jsx)(t.code,{children:"Running"})]}),"\n",(0,s.jsx)(t.li,{children:"Return tasks that transitioned successfully to you to execute your business logic"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The different between the Primary Subscriber and the Retry Subscriber in your point of view is small, you only need to change one line of code to get your Retry Subscriber to work."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:"  // other codes is same as the primary subscriber\n\n  // ------------ THE DIFFERENT IS HERE ---------\n  // use subscriber.NewRetry instead of subscriber.New\n  sub, err := subscriber.NewRetry(options, logger)\n  if err != nil {\n    panic(err)\n  }\n\n  // other codes is same as the primary subscriber\n"})}),"\n",(0,s.jsx)(t.h3,{id:"using-the-availability-subscriber",children:"Using the Availability Subscriber"}),"\n",(0,s.jsx)(t.p,{children:"If a task of event stays in the consumer for a long time and exceeds the visibility timeout, the Availability Subscriber will help you pull it out and work on it again."}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Set the new visibility time tasks"}),"\n",(0,s.jsx)(t.li,{children:"Return tasks that has updated successfully to you to execute your business logic"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The different between the Primary Subscriber and the Retry Subscriber in your point of view is small, you only need to change one line of code to get your Retry Subscriber to work."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:"  // other codes is same as the primary subscriber\n\n  // ------------ THE DIFFERENT IS HERE ---------\n  // use subscriber.NewRetry instead of subscriber.New\n  sub, err := subscriber.NewAvailability(options, logger)\n  if err != nil {\n    panic(err)\n  }\n\n  // other codes is same as the primary subscriber\n"})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var s=n(6540);const r={},i=s.createContext(r);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);