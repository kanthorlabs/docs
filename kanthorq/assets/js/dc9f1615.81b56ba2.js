"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8082],{8915:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>h});var t=n(4848),i=n(8453);const r={title:"Publisher",sidebar_label:"Publisher",sidebar_position:3},o=void 0,a={id:"concepts/publisher",title:"Publisher",description:"The Publisher is responsible for inserting events into the KanthorQ system. Technically, it functions as a simple query that inserts events\u2014nothing particularly special happens at this stage. However, when dealing with the insertion of multiple events in a short time, there are important performance considerations worth discussing.",source:"@site/docs/003-concepts/003-publisher.md",sourceDirName:"003-concepts",slug:"/concepts/publisher",permalink:"/kanthorq/docs/concepts/publisher",draft:!1,unlisted:!1,editUrl:"https://github.com/kanthorlabs/kanthorq/tree/main/packages/create-docusaurus/templates/shared/docs/003-concepts/003-publisher.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Publisher",sidebar_label:"Publisher",sidebar_position:3},sidebar:"default",previous:{title:"Subject",permalink:"/kanthorq/docs/concepts/subject"},next:{title:"Event",permalink:"/kanthorq/docs/concepts/event"}},c={},h=[{value:"Basic usecase",id:"basic-usecase",level:2},{value:"Batching usecase",id:"batching-usecase",level:2}];function l(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.strong,{children:"Publisher"})," is responsible for inserting events into the KanthorQ system. Technically, it functions as a simple query that inserts events\u2014nothing particularly special happens at this stage. However, when dealing with the insertion of multiple events in a short time, there are important performance considerations worth discussing."]}),"\n",(0,t.jsx)(s.h2,{id:"basic-usecase",children:"Basic usecase"}),"\n",(0,t.jsx)(s.p,{children:"In message brokers or queue systems, it's common to push a small number of events at a time. Here are a couple of typical scenarios:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"Webhook Events"}),": These are processed one by one and pushed into the queue individually."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:"E-commerce Systems"}),": When processing an order, related events such as ",(0,t.jsx)(s.code,{children:"order.updated"})," and ",(0,t.jsx)(s.code,{children:"payment.initialized"})," are published. For each order, typically a few events are triggered"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"In these basic cases, the performance of the KanthorQ system is limited by PostgreSQL's transactions-per-second (TPS) capacity. Given this limitation, there's not much room for optimization in these scenarios."}),"\n",(0,t.jsx)(s.h2,{id:"batching-usecase",children:"Batching usecase"}),"\n",(0,t.jsxs)(s.p,{children:["Things become more complex when you need to insert many events simultaneously. By ",(0,t.jsx)(s.strong,{children:"many"}),", we're referring to a few thousand events, not millions. At this scale, the system's performance bottlenecks become much more apparent."]}),"\n",(0,t.jsx)(s.p,{children:"There are two references that highlight performance issues when inserting a large number of events, each tested under different hardware configurations:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"https://radityaqb.medium.com/insert-5000-rows-per-second-using-postgresql-copy-30fcff1e8fd",children:"Insert 5000 rows per second using PostgreSQL Copy"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.a,{href:"https://www.timescale.com/learn/testing-postgres-ingest-insert-vs-batch-insert-vs-copy",children:"Testing Postgres Ingest: INSERT vs. Batch INSERT vs. COPY"})}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["Both references show that while ",(0,t.jsx)(s.em,{children:"INSERT"})," and ",(0,t.jsx)(s.em,{children:"BULK INSERT"})," methods perform adequately with small numbers of events, they struggle with larger batches. In contrast, the ",(0,t.jsx)(s.em,{children:"COPY"})," method offers significantly better performance for high-volume inserts. As the number of events increases, the performance gap between ",(0,t.jsx)(s.em,{children:"INSERT"}),", ",(0,t.jsx)(s.em,{children:"BULK INSERT"}),", and ",(0,t.jsx)(s.em,{children:"COPY"})," becomes more evident."]}),"\n",(0,t.jsxs)(s.admonition,{type:"info",children:[(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Why COPY command is better"})}),(0,t.jsxs)(s.p,{children:["According to official PostgreSQL documentation, using the COPY command (you can check it at ",(0,t.jsx)(s.a,{href:"https://www.postgresql.org/docs/current/populate.html#POPULATE-COPY-FROM",children:"Use COPY"}),") is almost always faster than using INSERT, even when PREPARE is used, and multiple insertions are batched within a single transaction."]}),(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Note that loading a large number of rows using COPY is almost always faster than using INSERT, even if PREPARE is used and multiple insertions are batched into a single transaction."})})]}),"\n",(0,t.jsxs)(s.p,{children:["In the KanthorQ system, we use the ",(0,t.jsx)(s.em,{children:"COPY"})," command by default for inserting events, due to its superior performance in handling larger batches."]}),"\n",(0,t.jsxs)(s.p,{children:["However, there is one caveat: KanthorQ uses the ",(0,t.jsx)(s.code,{children:"COPY %s ( %s ) FROM STDIN BINARY"})," statement under the hood to insert events. This means that events are buffered in memory before being copied into the database, leading to increased memory overhead if the events are large."]})]})}function d(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>o,x:()=>a});var t=n(6540);const i={},r=t.createContext(i);function o(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);